[{"content":"This first blog post inaugurates our series named \u0026ldquo;This Month in hax\u0026rdquo;: a series of short highlights of what happened in the development of hax and it\u0026rsquo;s ecosystem in the month.\nIn June, 30 PRs have been merged ðŸŽ‰! The detail is available below.\nOn the Rust side, we have updated the Rust compiler to a very recent nightly thanks to @Nadrieril! We also added support for more Rust features in the frontend (dyn Trait), more disciminant informations on ADTs, fixed various bugs, and improved the general experience of using hax.\nWe pushed many fixes for the F* backend in the engine and improved the F* proof library. We also improved the bounded integer library and it\u0026rsquo;s F* integration.\nMerged Pull Requests Translate dyn Trait information fix(engine/fstar): use Base.String.hash instead of String.hash feat: add LICENSE Update rustc all at once refactor(engine/fstar-ast): get rid of zarith and GMP Update rustc fix(engine/fstar): fix implicit discrepancies in traits feat(nix): reduce closure size for hax-engine Generalize bounded ints Don\u0026rsquo;t use strings to represent paths Update rustc Update intro.md: use latest version of gist for makefile fix(backends/fstar): no __marker_trait if parent bounds feat(proof-libs): add t_Default Fix typo in intro.md feat(hax): logging: enable tracing in release, add trait-related logs fix(exporter): disable impl expr resolution under type aliases fix: rename action for extracting ml-kem feat: isolate DefId: faster build times fix(README): always begin relative path with ./, rewrite in action fix(ci): newer version of ppx_deriving (6.0.2) loops indefinitely Update to OCaml 5 Export discriminant values in AdtDef Update README.md Bump rustc version Bump rustc version refactor(exporter): always use State::param_env fix(exporter): fixes #680 Engine: F*: fix #677 by always extracting implicit types Engine: F*: open modules providing trait impls ","permalink":"https://hacspec.github.io/blog/posts/this-month-in-hax/2024-06/","summary":"This first blog post inaugurates our series named \u0026ldquo;This Month in hax\u0026rdquo;: a series of short highlights of what happened in the development of hax and it\u0026rsquo;s ecosystem in the month.\nIn June, 30 PRs have been merged ðŸŽ‰! The detail is available below.\nOn the Rust side, we have updated the Rust compiler to a very recent nightly thanks to @Nadrieril! We also added support for more Rust features in the frontend (dyn Trait), more disciminant informations on ADTs, fixed various bugs, and improved the general experience of using hax.","title":"This month in hax: June 2024"},{"content":"We have been applying hax to verify several Rust pieces of software recently. hax was used to verify Libcrux\u0026rsquo;s implementation of ML-KEM with F*, but also for smart contracts verification with Coq, and even on protocols with F* and our new ProVerif backend.\nMeanwhile, we also presented hax at several conferences and workshops. The need for more documentation and guidance was becoming apparent: it was about time to have a tutorial!\nNew resources to learn more about hax The hax book has three new chapters:\nThe Quick start chapter explains how to go from a simple Rust crate to an F* extraction via hax, including how to install the tooling. The Tutorial chapter goes more in-depth into using hax and F* together to prove various properties of Rust code. The FAQ chapter is a work in progress but is intended to answer pragmatically and with examples to precise common issues or questions. Feel free to open an issue on the book repository if you feel like a topic should be addressed! We also added several examples of Rust verification via hax and F* in the example directory of hax, please check them out!\n","permalink":"https://hacspec.github.io/blog/posts/announcement-tutorial/","summary":"We have been applying hax to verify several Rust pieces of software recently. hax was used to verify Libcrux\u0026rsquo;s implementation of ML-KEM with F*, but also for smart contracts verification with Coq, and even on protocols with F* and our new ProVerif backend.\nMeanwhile, we also presented hax at several conferences and workshops. The need for more documentation and guidance was becoming apparent: it was about time to have a tutorial!","title":"Announcing the hax tutorial"},{"content":"This has been in the making for a while now. But we are finally happy to announce the first release of hax. It is still early days and we only tagged v0.1. But a ton of work has gone into this release.\nWait, what is hax?\nLet\u0026rsquo;s start at the beginning. A group of us started hacspec (high assurance crypto specifications), a language for specifying cryptographic primitives as the basis for formal verification, in early 2018 at the HACS workshop. After two iterations on hacspec the project outgrew the name and the initial crypto-oriented scope.\nHere comes hax. hax is a tool for high assurance translations that translates a large-ish subset of safe Rust into the formal languages accepted by proof assistants such as F* or Coq. Backends for other provers like EasyCrypt are under construction.\nThis is the result of joint work between the Prosecco team at Inria, Cryspen, and Prof. Spitters\u0026rsquo; group at Aarhus University.\nThe key design principle behind hax is hat we want to build a usable tool for verifying Rust programs without forcing the user to commit to a specific proof environment. In the future, we hope multiple tool developers will find it fruitful to build backends for hax.\nSo what is hacspec now?\nhacspec is a purely functional subset of Rust that can be used, together with a hacspec standard library, to write succinct, executable, and verifiable specifications in Rust. These specifications can be translated into formal languages with hax.\nhax There are a number of Rust verification projects out there. See, for example, Rust Verify and the Rust Formal Methods Interest Group. While most existing tools try to precisely model the most complex bits the Rust language, hax aims to be a usable and pragmatic tool that can analyze the kind of code Rust developers write on a daily basis, while abstracting away or ignoring Rust features it does not support. We believe that it is important in practice to have a usable tool that can ingest large Rust crates to show properties on certain parts of the code, instead of getting stuck on hard corner cases.\nhax has two parts: the exporter and the engine.\nThe Exporter When hax is invoked on a Rust crate, the exporter hooks into the Rust compiler. Compiling a program, Rust transformes the user source code to various internal representations in an optimized fashion (essentially HIR, THIR and MIR, illustrated in the diagram below). While this is great within the compiler, those representations are not friendly to external tool consumption.\nThe hax exporter is a Rust driver that provides a bridge from those unstable internal representations to fixed and easy-to-consume ASTs1 (abstract syntax trees). The JSON node on the diagram below represents those ASTs.\nThe hax exporter is not opinionated toward the hax project: it can be used as a frontend to the Rust compiler in other projects. For example, we are working with the Aeneas project towards sharing the exporter code between the two tools.\nThe Engine The magic of hax really happens in the engine, written in OCaml. It directly consumes2 the output of the exporter, that is, the ASTs exported for your crate of choice.\nUpon the backend choice (for instance: shall we extract to F* or to Coq?), the engine proceeds to a sequence of typed3 program transformations, eventually landing into the sublanguage supported by the targeted language, e.g. F*.\nThe various program transformations are called phases. We have a dozen of them:\ntransforming and functionalizing for loops; functionalizing local mutation; rewrite functions with mutable references as inputs into state-passing code; and many more! Those phases are statically typed: for instance, making for loops functional is not possible on an AST that still contains local mutation. Such constraints are ensured statically, reducing opportunities for bugs.\nThis typed phase design allows us to target heterogeneous languages: for instance, we already support a backend in the imperative language of the SSProve Coq library. This comes with an automatic proof that it is equivalent to the functional interpretation. This can be seen as a case-by-case correctness proof of hax.\nThis design can be used as a template for the upcoming backend which targets the imperative language of EasyCrypt.\nUsage hax is still heavily under development. It is therefore recommended to install it straight from the git repository (see the Installation section in the readme).\nAfter installing it you can call it from any Rust crate.\ncargo hax into fstar This will extract the crate to F*. Similarly, cargo hax into coq will extract the crate to Coq.\nFor more options use\ncargo hax into --help Example We walk through a sample usage of hax based on an example. The example can be found in the git repository.\nGo to the proofs/fstar/extraction directory and run make. This will first call\ncargo hax into -i \u0026#39;-** +**::process_order\u0026#39; fstar in order to extract the process_order order function to F*. This demonstrates one particularly useful feature in hax, which allows extracting only a small portion or single function from a much larger crate. The argument -i '-** +**::process_order' tells hax to include the process_order function in any module and exclude (-**) everything else. In addition to the function itself, hax extracts all the required dependencies within the crate as well.\nRust fn process_order\u0026lt;T\u0026gt;(mut order: Order, other_side: \u0026amp;mut BinaryHeap\u0026lt;T\u0026gt;) -\u0026gt; (Vec\u0026lt;Match\u0026gt;, Option\u0026lt;Order\u0026gt;) where T: Into\u0026lt;Order\u0026gt; + From\u0026lt;Order\u0026gt; + Ord + Clone, { ... if let Some(m) = other_side .peek() .and_then(|other| Into::into(other.clone()).try_match(\u0026amp;order)) { order.quantity -= m.quantity; let mut other: Order = Into::into(other_side.pop().unwrap()); other.quantity -= m.quantity; if other.quantity \u0026gt; 0 { other_side.push(From::from(other.clone())); } matches.push(m); } else { done = true; } ... } F* match Core.Option.impl__and_then (Alloc.Collections.Binary_heap.impl_10__peek other_side \u0026lt;: Core.Option.t_Option v_T) (fun other -\u0026gt; impl__Order__try_match (Core.Convert.f_into (Core.Clone.f_clone other \u0026lt;: v_T) \u0026lt;: t_Order) order \u0026lt;: Core.Option.t_Option t_Match) \u0026lt;: Core.Option.t_Option t_Match with | Core.Option.Option_Some m -\u0026gt; let order:t_Order = { order with f_quantity = order.f_quantity -! m.f_quantity } in let tmp0, out:(Alloc.Collections.Binary_heap.t_BinaryHeap v_T \u0026amp; Core.Option.t_Option v_T) = Alloc.Collections.Binary_heap.impl_9__pop other_side in let other_side:Alloc.Collections.Binary_heap.t_BinaryHeap v_T = tmp0 in let hoist1:Core.Option.t_Option v_T = out in let hoist2:v_T = Core.Option.impl__unwrap hoist1 in let (other: t_Order):t_Order = Core.Convert.f_into hoist2 in let other:t_Order = { other with f_quantity = other.f_quantity -! m.f_quantity } in let other_side:Alloc.Collections.Binary_heap.t_BinaryHeap v_T = if other.f_quantity \u0026gt;. 0uL then let other_side:Alloc.Collections.Binary_heap.t_BinaryHeap v_T = Alloc.Collections.Binary_heap.impl_9__push other_side (Core.Convert.f_from (Core.Clone.f_clone other \u0026lt;: t_Order) \u0026lt;: v_T) in other_side else other_side in let matches:Alloc.Vec.t_Vec t_Match Alloc.Alloc.t_Global = Alloc.Vec.impl_1__push matches m in done, matches, order, other_side | _ -\u0026gt; let done:bool = true in done, matches, order, other_side Then the makefile calls F* on the generated output. The successful typechecking in F* proves two properties on the Rust code.\nNon-panicking subtraction First, it shows that the lines with\norder.quantity -= m.quantity; do not underflow.\nConcretely, in Rust, the subtraction on u64 integers is a partial operation: the subtraction of x and y (x - y) is defined only when x is greater or equal to y such that x - y \u0026gt;= 0.\nSuch a requirement cannot be expressed as a Rust type, thus Rust\u0026rsquo;s subtraction panics (in debug mode) when it is called with bad inputs.\nIn contrast, F* is ideal to express such types! We model Rust\u0026rsquo;s subtraction as a total function with a strong type signature:\nval ( -! ): x: u64 -\u0026gt; y: u64 {x \u0026gt;=. y} -\u0026gt; u64 This strong signature implies a proof obligation: whenever this F* subtraction is used, F* won\u0026rsquo;t typecheck unless it finds a proof that x \u0026gt;=. y holds.\nTherefore, typechecking in F* implies that order.quantity -= m.quantity; never underflows.\nNon-panicking unwrap Second, it shows that\nother_side.pop().unwrap() never panics, i.e. the pop always returns Some value and thus unwrap never panics.\nSimilarly to subtraction, in F*, using unwrap requires a proof that the option being unwrapped is not None.\nCall to Action hax is still under heavy development and there are many features we want to add, and many bugs to squash. We invite everyone to contribute to the project with new backends, contributing to the hax frontend or backend, or provide examples to exercise the tool.\nThe F* backend is currently being developed by the Inria Prosecco team, the Coq backend by the Aarhus team, and an EasyCrypt backend is in the works by the EasyCrypt team. We are also working with the Aeneas project to allow better interoperability between their sophisticated stateful Rust verification toolchain and hax.\nResources Zulip Git Repository Rust\u0026rsquo;s internal ASTs are very optimized in memory and require constantly to lookup things interactively with the Rust compiler. Instead, our ASTs are indirection-free trees packing as much informations as possible (e.g. types, attributes, spans\u0026hellip;), ready for direct consumption.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nThe exporter expose big ASTs as JSON. The Rust type definitions of those ASTs are automatically converted into OCaml type definition along with JSON serializer and deserializers, using JSON Schemas.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nThe internal AST used by the hax engine is functorized. This enables AST transformations to be strongly typed.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://hacspec.github.io/blog/posts/hax-v0-1/","summary":"This has been in the making for a while now. But we are finally happy to announce the first release of hax. It is still early days and we only tagged v0.1. But a ton of work has gone into this release.\nWait, what is hax?\nLet\u0026rsquo;s start at the beginning. A group of us started hacspec (high assurance crypto specifications), a language for specifying cryptographic primitives as the basis for formal verification, in early 2018 at the HACS workshop.","title":"Introducing hax ðŸŽ‚"}]