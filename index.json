[{"content":"This has been in the making for a while now. But we are finally happy to announce the first release of hax. It is still early days and we only tagged v0.1. But a ton of work has gone into this release.\nWait, what is hax?\nLet\u0026rsquo;s start at the beginning. We started hacspec (high assurance crypto specifications), a language for specifying cryptographic primitives as the basis for formal verification, in early 2018 at the HACS workshop. After two iterations on hacspec the project outgrew the name.\nHere comes hax. hax is a tool for high assurance translations that translates a large subset of Rust into formal languages such as F* or Coq. This extends the scope of the project, which was previously a DSL embedded in Rust, to a usable tool for verifying Rust programs.\nSo what is hacspec now?\nhacspec is the functional subset of Rust that can be used, together with a hacspec standard library, to write succinct, executable, and verifiable specifications in Rust. These specifications can be translated into formal languages with hax.\nhax There are a number of Rust verification projects out there, for example Kani, Crux-Mir, or MIRAI. While most of them try to precisely model a large part of the Rust language, hax aims to be a usable tool that captures a large subset of Rust without trying to capture or model everything. We believe that it is more important in practice to have a usable tool that ingests large Rust crates to show properties on certain parts of the code, instead of modelling the entire Rust language.\nhax has two parts: the exporter and the engine.\nThe Exporter When hax is invoked on a Rust crate, the exporter hooks into the Rust compiler. Compiling a program, Rust transformes the user source code to various internal representations in an optimized fashion (essentially HIR, THIR and MIR, illustrated in the diagram below). While this is great within the compiler, those representations are not friendly to external tool consumption.\nThe hax exporter is a Rust driver that provides a bridge from those unstable internal representations to fixed and easy-to-consume ASTs1 (abstract syntax trees). The JSON node on the diagram below represents those ASTs.\nThe hax exporter is not opinionated toward the hax project: it can be used as a frontend to the Rust compiler in other projects. For example, the Aeneas toolchain is already moving toward our exporter.\nThe Engine The magic of hax really happens in the engine, written in OCaml. It directly consumes2 the output of the exporter, that is, the ASTs exported for your crate of choice.\nUpon the backend choice (for instance: shall we extract to F* or to Coq?), the engine proceeds to a sequence of typed3 program transformations, eventually landing into the sublanguage supported by the targeted language, e.g. F*.\nThe various program transformations are called phases. We have a dozen of them:\ntransforming and functionalizing for loops; functionalizing local mutation; rewrite functions with mutable references as inputs into state-passing; and many more! Those phases are statically typed: for instance, making for loops functional is not possible on an AST that still contains local mutation. Such constraints are ensured statically, reducing opportunities for bugs.\nThis typed phase design allows us to target heterogeneous languages: for instance F* and EasyCrypt.\nUsage hax is still heavily under development. It is therefore recommended to install it straight from the git repository (see the Installation section in the readme).\nAfter installing it you can call it from any Rust crate.\ncargo hax into fstar This will extract the crate to F*. Similarly, cargo hax into coq will extract the crate to Coq.\nFor more options use\ncargo hax into --help Example We walk through a sample usage of hax based on an example. The example can be found in the git repository.\nGo to the proofs/fstar/extraction directory and run make. This will first call\ncargo hax into -i \u0026#39;-** +**::process_order\u0026#39; fstar in order to extract the process_order order function to F*. This demonstrates one particularly useful feature in hax, which allows extracting only a small portion or single function from a much larger crate. The argument -i '-** +**::process_order' tells hax to include the process_order function in any module and exclude (-**) everything else. In addition to the function itself, hax extracts all the required dependencies within the crate as well.\nRust fn process_order\u0026lt;T\u0026gt;(mut order: Order, other_side: \u0026amp;mut BinaryHeap\u0026lt;T\u0026gt;) -\u0026gt; (Vec\u0026lt;Match\u0026gt;, Option\u0026lt;Order\u0026gt;) where T: Into\u0026lt;Order\u0026gt; + From\u0026lt;Order\u0026gt; + Ord + Clone, { ... if let Some(m) = other_side .peek() .and_then(|other| Into::into(other.clone()).try_match(\u0026amp;order)) { order.quantity -= m.quantity; let mut other: Order = Into::into(other_side.pop().unwrap()); other.quantity -= m.quantity; if other.quantity \u0026gt; 0 { other_side.push(From::from(other.clone())); } matches.push(m); } else { done = true; } ... } F* match Core.Option.impl__and_then (Alloc.Collections.Binary_heap.impl_10__peek other_side \u0026lt;: Core.Option.t_Option v_T) (fun other -\u0026gt; impl__Order__try_match (Core.Convert.f_into (Core.Clone.f_clone other \u0026lt;: v_T) \u0026lt;: t_Order) order \u0026lt;: Core.Option.t_Option t_Match) \u0026lt;: Core.Option.t_Option t_Match with | Core.Option.Option_Some m -\u0026gt; let order:t_Order = { order with f_quantity = order.f_quantity -! m.f_quantity } in let tmp0, out:(Alloc.Collections.Binary_heap.t_BinaryHeap v_T \u0026amp; Core.Option.t_Option v_T) = Alloc.Collections.Binary_heap.impl_9__pop other_side in let other_side:Alloc.Collections.Binary_heap.t_BinaryHeap v_T = tmp0 in let hoist1:Core.Option.t_Option v_T = out in let hoist2:v_T = Core.Option.impl__unwrap hoist1 in let (other: t_Order):t_Order = Core.Convert.f_into hoist2 in let other:t_Order = { other with f_quantity = other.f_quantity -! m.f_quantity } in let other_side:Alloc.Collections.Binary_heap.t_BinaryHeap v_T = if other.f_quantity \u0026gt;. 0uL then let other_side:Alloc.Collections.Binary_heap.t_BinaryHeap v_T = Alloc.Collections.Binary_heap.impl_9__push other_side (Core.Convert.f_from (Core.Clone.f_clone other \u0026lt;: t_Order) \u0026lt;: v_T) in other_side else other_side in let matches:Alloc.Vec.t_Vec t_Match Alloc.Alloc.t_Global = Alloc.Vec.impl_1__push matches m in done, matches, order, other_side | _ -\u0026gt; let done:bool = true in done, matches, order, other_side Then the makefile calls F* on the generated output. The successful typechecking in F* proves two properties on the Rust code.\nNon-panicking subtraction First, it shows that the lines with\norder.quantity -= m.quantity; do not underflow.\nConcretely, in Rust, the subtraction on u64 integers is a partial operation: the subtraction of x and y (x - y) is defined only when x is greater or equal to y such that x - y \u0026gt;= 0.\nSuch a requirement cannot be expressed as a Rust type, thus Rust\u0026rsquo;s subtraction panics (in debug mode) when it is called with bad inputs.\nIn contrast, F* is ideal to express such types! We model Rust\u0026rsquo;s subtraction as a total function with a strong type signature:\nval ( -! ): x: u64 -\u0026gt; y: u64 {x \u0026gt;=. y} -\u0026gt; u64 This strong signature implies a proof obligation: whenever this F* subtraction is used, F* won\u0026rsquo;t typecheck unless it finds a proof that x \u0026gt;=. y holds.\nTherefore, typechecking in F* implies that order.quantity -= m.quantity; never underflows.\nNon-panicking unwrap Second, it shows that\nother_side.pop().unwrap() never panics, i.e. the pop always returns Some value and thus unwrap never panics.\nSimilarly to subtraction, in F*, using unwrap requires a proof that the option being unwrapped is not None.\nCall to Action hax is still under heavy development and there are many features we want to add, and many bugs to squash. We invite everyone to contribute to the project with new backends, contributing to the hax frontend or backend, or provide examples to exercise the tool.\nResources Zulip Git Repository Rust\u0026rsquo;s internal ASTs are very optimized in memory and require constantly to lookup things interactively with the Rust compiler. Instead, our ASTs are indirection-free trees packing as much informations as possible (e.g. types, attributes, spans\u0026hellip;), ready for direct consumption.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nThe exporter expose big ASTs as JSON. The Rust type definitions of those ASTs are automatically converted into OCaml type definition along with JSON serializer and deserializers, using JSON Schemas.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nThe internal AST used by the hax engine is functorized. This enables AST transformations to be strongly typed.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://hacspec.github.io/blog/posts/hax-v0-1/","summary":"This has been in the making for a while now. But we are finally happy to announce the first release of hax. It is still early days and we only tagged v0.1. But a ton of work has gone into this release.\nWait, what is hax?\nLet\u0026rsquo;s start at the beginning. We started hacspec (high assurance crypto specifications), a language for specifying cryptographic primitives as the basis for formal verification, in early 2018 at the HACS workshop.","title":"Introducing hax ðŸŽ‚"}]